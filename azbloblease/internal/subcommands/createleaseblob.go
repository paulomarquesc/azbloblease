// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

// TODO: This sample tool downloads Azure Key Vault Managed certificates
// they can be self-signed certs or certs generated by CAs integrated
// with AKV. The format can be be PKCS12 or PEM.

package subcommands

import (
	"bytes"
	"context"
	"crypto/rand"
	"fmt"
	"net/url"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/cloud"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/storage/armstorage"
	"github.com/Azure/azure-sdk-for-go/sdk/storage/azblob"
	"github.com/Azure/azure-sdk-for-go/sdk/storage/azblob/blockblob"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/paulomarquesc/azbloblease/azbloblease/internal/common"
	"github.com/paulomarquesc/azbloblease/azbloblease/internal/config"
	"github.com/paulomarquesc/azbloblease/azbloblease/internal/models"
	"github.com/paulomarquesc/azbloblease/azbloblease/internal/utils"
)

// CreateLeaseBlob - creates a blob to be used for storage lease process
func CreateLeaseBlob(cntx context.Context, subscriptionID, resourceGroupName, accountName, container, blobName, environment string, cred azcore.TokenCredential) models.ResponseInfo {

	//-------------------------------------
	// Operations based on storage mgmt sdk
	//-------------------------------------
	response := models.ResponseInfo{
		SubscriptionID:     &subscriptionID,
		ResourceGroupName:  &resourceGroupName,
		StorageAccountName: &accountName,
		ContainerName:      &container,
		BlobName:           &blobName,
		Status:             to.StringPtr(config.Fail()),
	}

	// Getting storage client
	cloudConfig := cloud.Configuration{}

	if environment == "AZUREUSGOVERNMENTCLOUD" {
		cloudConfig = cloud.AzureGovernment
	} else if environment == "AZURECHINACLOUD" {
		cloudConfig = cloud.AzureChina
	} else if environment == "CUSTOMCLOUD" {
		// TODO:
		cloudConfig = cloud.Configuration{}
	} else {
		cloudConfig = cloud.AzurePublic
	}

	options := arm.ClientOptions{
		ClientOptions: azcore.ClientOptions{
			Cloud: cloudConfig,
		},
	}

	storageClientFactory, err := armstorage.NewClientFactory(subscriptionID, cred, &options)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("an error ocurred while storage account client: %v", err), config.Stderr())
		response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
		return response
	}

	storageAccountClient := storageClientFactory.NewAccountsClient()

	accountKeys, err := storageAccountClient.ListKeys(cntx, resourceGroupName, accountName, nil)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("an error ocurred while getting storage account keys: %v.", err), config.Stderr())
		response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
		return response
	}

	//-----------------------------------
	// Operations based on azblob package
	//-----------------------------------

	// Create a credential object; this is used to access account while using azblob module.
	credential, err := azblob.NewSharedKeyCredential(accountName, *accountKeys.Keys[0].Value)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("an error ocurred while obtaining azblob credential: %v.", err), config.Stderr())
		response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
		return response
	}

	// Getting blob endpoint
	blobEndppointURL, err := url.Parse(
		common.GetAccountBlobEndpoint(cntx, storageAccountClient, resourceGroupName, accountName),
	)

	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("an error ocurred while obtaining blob endpoint: %v.", err), config.Stderr())
		response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
		return response
	}

	// Getting a blob client to be used in container operations
	azBlobClient, err := azblob.NewClientWithSharedKeyCredential(blobEndppointURL.String(), credential, nil)

	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("an error ocurred while obtaining az blob client: %v", err), config.Stderr())
		response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
		return response
	}

	// Create an ServiceURL object that wraps the service URL and a request pipeline.
	containerClient := azBlobClient.ServiceClient().NewContainerClient(container)

	// Check if container already exists
	_, err = containerClient.GetProperties(cntx, nil)
	if err != nil {
		if !strings.Contains(err.Error(), "ContainerNotFound") {
			utils.ConsoleOutput(fmt.Sprintf("an error occurred while checking if container %v exists: %v", container, err), config.Stderr())
			response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
			return response
		}

		// Let's create a new container
		_, err = containerClient.Create(cntx, &azblob.CreateContainerOptions{})
		if err != nil {
			utils.ConsoleOutput(fmt.Sprintf("an error occurred trying to create container %v: %v", container, err), config.Stderr())
			response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
			return response
		}
	}

	// Getting specific blob client
	blobURL := fmt.Sprintf("%v%v/%v", blobEndppointURL.String(), container, blobName)

	blobClient, err := blockblob.NewClientWithSharedKeyCredential(blobURL, credential, nil)
	if err != nil {
		utils.ConsoleOutput(fmt.Sprintf("an error occurred trying to create blob client for blob %v, error: %v", blobURL, err), config.Stderr())
		response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
		return response
	}

	_, err = blobClient.GetProperties(cntx, nil)
	if err != nil {
		if !strings.Contains(err.Error(), "BlobNotFound") {
			utils.ConsoleOutput(fmt.Sprintf("an error occurred while checking if blob %v exists: %v", blobName, err), config.Stderr())
			response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
			return response
		}

		// Perform UploadStream to create new blob for leasing

		// Create some data for the upload stream
		blobSize := 1024 // 1KB
		data := make([]byte, blobSize)
		rand.Read(data)

		_, err = blobClient.UploadStream(
			cntx,
			bytes.NewReader(data),
			&blockblob.UploadStreamOptions{},
		)

		if err != nil {
			utils.ConsoleOutput(fmt.Sprintf("an error occurred while uploading blob stream: %v", err), config.Stderr())
			response.ErrorMessage = to.StringPtr(strings.Replace(err.Error(), "\"", "", -1))
			return response
		}
		response.Status = to.StringPtr(config.Success())
		return response
	}

	response.Status = to.StringPtr(config.SuccessAlreadyExists())
	return response
}
